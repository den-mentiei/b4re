#!/usr/bin/env python

import sys
import os
import pprint
import pystache

TEMPLATE = r"""// It is autogenerated! :)

typedef struct {
	const char* name;
	const char* texture_path;

	bgfx_texture_handle_t h;
} sprite_t;

// TODO:

"""

GROUP_INIT_TEMPLATE = r""".{{name}} = {
    .name = "{{name}}",
    {{#sprites}}
    .{{name}} = { "{{name}}", "{{path}}" },
    {{/sprites}}
	{{#groups}}
    {{> group_init}}
	{{/groups}}
},
"""

GROUP_DECL_TEMPLATE = r"""struct {
    const char* name;
    {{#sprites}}
    sprite_t {{name}};
    {{/sprites}}
    {{#groups}}
    {{> group_decl}}
    {{/groups}}
} {{name}};
"""

GROUP_LOAD_TEMPLATE = r""".{{name}} = {
    .name = "{{name}}",
    {{#sprites}}
    .{{name}} = load("{{name}}", "{{path}}"),
    {{/sprites}}
	{{#groups}}
    {{> group_load}}
	{{/groups}}
},
"""

HEADER_TEMPLATE = r"""#pragma once

// It is auto-generated :)

typedef struct {
    {{#groups}}
	{{> group_decl}}
    {{/groups}}
} sprites_t;

void assets_init();
void assets_shutdown();

const sprites_t* assets_sprites();
"""

IMPLEMENTATION_TEMPLATE = r"""//It is auto-generated :)

#include "assets.h"

static sprites_t s_sprites;

static bgfx_texture_handle_t load(const char* name, const char* path) {
    // TODO:
}

void assets_init() {
    s_sprites = {
    {{#groups}}
        {{> group_load}}
    {{/groups}}
    };
}

void assets_shutdown() {
    // TODO:
}
"""

PARTIALS = {
	'group_decl': GROUP_DECL_TEMPLATE,
	'group_init': GROUP_INIT_TEMPLATE,
	'group_load': GROUP_LOAD_TEMPLATE,
}

def split_path(path):
	return os.path.normpath(path).split(os.path.sep)

def make_empty_group():
	return { 'children': {}, 'files': [] }

def build_subtree(d, parts):
	for p in parts:
		if p not in d['children']:
			d['children'][p] = make_empty_group()
		d = d['children'][p]
	return d

def is_sprite_texture(name):
	return os.path.splitext(name)[1] == '.png'

def traverse_assets(root, is_asset):
	assets = make_empty_group()
	for (path, dirs, files) in os.walk(root):
		s = build_subtree(assets, split_path(path))
		s['files'] = [os.path.join(path, f) for f in files if is_asset(f)]
	return assets

def make_sprite(f):
	name = os.path.splitext(os.path.basename(f))[0].replace('-', '_')
	return {'name': name, 'path': f}

def make_group(name, leaf):
	sprites = [make_sprite(f) for f in leaf['files']]
	nested  = [make_group(k, v) for (k, v) in leaf['children'].items()]
	return {
		'name':    name,
		'groups':  nested,
		'sprites': sprites
	}

def build_sprites(assets):
	return make_group('root', assets)

def dump(x):
	p = pprint.PrettyPrinter(indent=2)
	p.pprint(x)

def main():
	if len(sys.argv) != 2:
		raise Exception('pass an argument that is a directory name to scan for assets in')

	sprites = build_sprites(traverse_assets(sys.argv[1], is_sprite_texture))

	r = pystache.Renderer(partials=PARTIALS)
	with open('assets.h', 'w') as f:
		f.write(r.render(HEADER_TEMPLATE, sprites))
	with open('assets.c', 'w') as f:
		f.write(r.render(IMPLEMENTATION_TEMPLATE, sprites))

if __name__ == '__main__':
	main()
